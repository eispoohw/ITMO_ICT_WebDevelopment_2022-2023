{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IFMO WebDevelopment Course Results of Laboratory Work in the Web Development Course at IFMO University. Author: Kormanovskaya Darina , K33401 Labs Working with sockets Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket , threading","title":"Home"},{"location":"#ifmo-webdevelopment-course","text":"Results of Laboratory Work in the Web Development Course at IFMO University. Author: Kormanovskaya Darina , K33401","title":"IFMO WebDevelopment Course"},{"location":"#labs","text":"Working with sockets Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket , threading","title":"Labs"},{"location":"lab1/","text":"Laboratory Work 1: Working with sockets Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket, threading Task 1 Implement the client and server part of the application. The client sends a \"Hello, server\" message to the server. The message must be reflected on the server side. The server responds with a \"Hello, client\" message to the client. The message must be displayed to the client. Implement using the UDP protocol. config.py contains the necessary constants # address properties import socket HOST = socket.gethostbyname(socket.gethostname()) PORT = 7171 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' server.py creates a server socket and waits for messages from the client from config import * CONNECT_MSG = \"Hello, client!\" def main(): UDPServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPServer.bind(ADDR) print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: msg, addr = UDPServer.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") UDPServer.sendto(CONNECT_MSG.encode(FORMAT), addr) if __name__ == \"__main__\": main() client.py connects to the server and sends it a message from config import * CONNECT_MSG = \"Hello, server!\" def main(): UDPClient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPClient.sendto(CONNECT_MSG.encode(FORMAT), ADDR) msg, addr = UDPClient.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") if __name__ == \"__main__\": main() Task 2 Implement the client and server part of the application. The client asks the server to perform a mathematical operation: solving a quadratic equation, the parameters of which are entered from the keyboard. The server processes the received data and returns the result to the client. Implement using the TCP protocol config.py contains the necessary constants import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7272 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' MISTAKE = \"[INVALID INPUT] three coefficients needed, separated by space. Example: 1 2 3\" server.py creates a server socket, checks the input and sends an answer if possible from config import * from math import sqrt def calculate(a: float, b: float, c: float) -> str: d = b * b - 4 * a * c if d < 0: return 'No real roots' else: return ', '.join(str(r) for r in {(-b - sqrt(d)) / 2 / a, (-b + sqrt(d)) / 2 / a}) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen(1) print(f\"[STARTED] Server is listening on {HOST}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) print(f\"[NEW REQUEST from {addr[0]}:{addr[1]}]: {data.decode(FORMAT)}\") if not data: break try: values = [float(i) for i in data.decode(FORMAT).split(' ')] if len(values) != 3: raise ValueError conn.sendall(calculate(*values).encode(FORMAT)) except ValueError: conn.sendall(MISTAKE.encode(FORMAT)) print(\"the result was sent!\") conn.close() if __name__ == \"__main__\": main() client.py connects to the server and sends it values from config import * def main(): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(ADDR) print(f\"You are connected to {HOST}:{PORT}, \" f\"which calculates the roots of the quadratic equation:\" f\" a*x^2 + b*x + c = 0\") while True: try: inp = input(\"Enter the a, b, c: \") values = [float(i) for i in inp.split(' ')] if len(values) != 3: raise ValueError client.sendall(inp.encode(FORMAT)) print(f\"Answer: {client.recv(1024).decode(FORMAT)}\") break except ValueError: print(MISTAKE) if __name__ == \"__main__\": main() Task 3 Implement the server part of the application. The client connects to the server. In response The client receives an http message containing a html page, which the server The client receives a http message containing a page which the server loads from the index.html file. index.html response template <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Lab 1 | Task 3</title> </head> <body> <iframe width=\"80%\" height=\"713\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ\" title=\"Rick Astley - Never Gonna Give You Up (Official Music Video)\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media;\" allowfullscreen style=\"margin-left: 10%; margin-right: 10%\"></iframe> </body> </html> server.py responding with HTML send_answer() sending HTTP answer, which contains index.html template, to the client main() - creating server socket and running it import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7373 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' def send_answer(conn, status=\"200 OK\", typ=\"text/html; charset=utf-8\", data=\"\"): conn.broadcast(b\"HTTP/1.1 \" + status.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"Server: simplehttp\\r\\n\") conn.broadcast(b\"Connection: close\\r\\n\") conn.broadcast(b\"Content-Type: \" + typ.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"\\r\\n\") conn.broadcast(data.encode(FORMAT)) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen() print(f\"[STARTED] Server is listening on {HOST}:{PORT}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) if not data: break print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") send_answer(conn, data=open('index.html', 'r').read()) conn.close() if __name__ == \"__main__\": main() Task 4 Implement multiplayer chat. config.py contains the necessary constants import socket from threading import Thread # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7474 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' ASKING = \"Enter your username: \" server.py contains class Chat - s: socket.socket - server socket - users: Dict[socket.socket, str] - dictionary where key is client socket, value - username broadcast() - sending a message to all clients in users handle() - handling clients messages run() - starting server from typing import Dict from config import * class Chat: def __init__(self, host, port): self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.bind((HOST, PORT)) self.users: Dict[socket.socket, str] = dict() def broadcast(self, msg: str, username: str): for un in self.users: if self.users[un] == username: continue un.send(f\"{username}: {msg}\".encode(FORMAT)) def handle(self, user: socket.socket): while True: try: msg = user.recv(BUFFER_SIZE).decode(FORMAT) self.broadcast(msg, self.users[user]) except OSError: user.close() msg = f\"{self.users[user]} has left the chat :'(\" self.users.pop(user) self.broadcast(msg, '[sys]') break def run(self): self.s.listen() print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: conn, addr = self.s.accept() print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") conn.send(ASKING.encode(FORMAT)) username = conn.recv(1024).decode(FORMAT) self.users[conn] = username self.broadcast(f\"{username} has connected to the chat\", \"[sys]\") thread = Thread(target=self.handle, args=[conn]) thread.start() def main(): print('Server is starting...') chat = Chat(HOST, PORT) chat.run() if __name__ == \"__main__\": main() client.py Contains class User - username: str - client username - s: socket.socket - client socket receive() - getting messages from the server send() - sending new message to the server start() - starting client socket thread from config import * class User: def __init__(self, address): self.username = \"\" self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect(address) def receive(self): while True: try: msg = self.s.recv(BUFFER_SIZE).decode(FORMAT) if msg == ASKING: self.s.send(self.username.encode(FORMAT)) else: print(msg) except: print('Something went wrong. Disconnecting!') self.s.close() break def send(self): while True: msg = input() self.s.send(msg.encode(FORMAT)) def start(self): self.username = input(ASKING) recv_thread = Thread(target=self.receive) recv_thread.start() send_thread = Thread(target=self.send) send_thread.start() def main(): user = User(ADDR) user.start() if __name__ == \"__main__\": main() Task 5 Write a simple web-server to handle GET and POST http requests by means of Python and socket library. request.py contains Request class and Response class from functools import lru_cache from urllib.parse import parse_qs, urlparse class Request: def __init__(self, method, target, version, headers, rfile): self.method = method self.target = target self.version = version self.headers = headers self.rfile = rfile @property def path(self): return self.url.path @property @lru_cache(maxsize=None) def query(self): return parse_qs(self.url.query) @property @lru_cache(maxsize=None) def url(self): return urlparse(self.target) def body(self): size = self.headers.get('Content-Length') if not size: return None return self.rfile.read(size) class Response: def __init__(self, status, reason, headers=None, body=None): self.status = status self.reason = reason self.headers = headers self.body = body server.py HTTPServer. Source: https://iximiuz.com/ru/posts/writing-python-web-server-part-3/ import json import socket from request import Request, Response from email.parser import Parser MAX_LINE = 64 * 1024 MAX_HEADERS = 100 class MyHTTPServer: def __init__(self, host, port, name): self._host = host self._port = port self._name = name self._marks = {'\u0424\u0438\u0437\u043a\u0443\u043b\u044c\u0442\u0443\u0440\u0430': 5} print(f\"[RUNNING] Created HTTPServer '{name}'\") def serve_forever(self): serv_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0) try: serv_sock.bind((self._host, self._port)) serv_sock.listen() print(f\"[LISTENING] Server '{self._name}' on {self._host}:{self._port}\\r\\n\") while True: conn, addr = serv_sock.accept() print(f\"[NEW]: {addr}\") try: self.serve_client(conn) except Exception as e: print('[ERROR]: Client serving failed', e) finally: print('[EXIT]') serv_sock.close() def serve_client(self, conn): try: req = self.parse_request(conn) resp = self.handle_request(req) self.send_response(conn, resp) except ConnectionResetError: conn = None except Exception as e: self.send_error(conn, e) if conn: req.rfile.close() conn.close() def parse_request(self, conn): rfile = conn.makefile('rb') method, target, ver = self.parse_request_line(rfile) headers = self.parse_headers(rfile) host = headers.get('Host') if not host: raise HTTPError(400, 'Bad request', 'Host header is missing') if host != f'{self._host}:{self._port}': raise HTTPError(404, 'Not found') return Request(method, target, ver, headers, rfile) @staticmethod def parse_request_line(rfile): raw = rfile.readline(MAX_LINE + 1) if len(raw) > MAX_LINE: raise HTTPError(400, 'Bad request', 'Request line is too long') req_line = str(raw, 'iso-8859-1') words = req_line.split() if len(words) != 3: raise HTTPError(400, 'Bad request', 'Malformed request line') method, target, ver = words if ver != 'HTTP/1.1': raise HTTPError(505, 'HTTP Version Not Supported') return method, target, ver @staticmethod def parse_headers(rfile): headers = [] while True: line = rfile.readline(MAX_LINE + 1) if len(line) > MAX_LINE: raise HTTPError(494, 'Request header too large') if line in (b'\\r\\n', b'\\n', b''): break headers.append(line) if len(headers) > MAX_HEADERS: raise HTTPError(494, 'Too many headers') sheaders = b''.join(headers).decode('iso-8859-1') return Parser().parsestr(sheaders) def handle_request(self, req): if req.path == '/update' and req.method == 'POST': return self.handle_post_mark(req) if req.path == '/marks' and req.method == 'GET': return self.handle_get_marks(req) raise HTTPError(404, 'Not found') def send_response(self, conn, resp): wfile = conn.makefile('wb') status_line = f'HTTP/1.1 {resp.status} {resp.reason}\\r\\n' wfile.write(status_line.encode('iso-8859-1')) if resp.headers: for (key, value) in resp.headers: header_line = f'{key}: {value}\\r\\n' wfile.write(header_line.encode('iso-8859-1')) wfile.write(b'\\r\\n') if resp.body: wfile.write(resp.body) wfile.flush() wfile.close() def send_error(self, conn, err): try: status = err.status reason = err.reason body = (err.body or err.reason).encode('utf-8') except: status = 500 reason = b'Internal Server Error' body = b'Internal Server Error' resp = Response(status, reason, [('Content-Length', len(body))], body) self.send_response(conn, resp) def handle_post_mark(self, req): self._marks[req.query['name'][0]] = req.query['mark'][0] return Response(204, 'Created') def handle_get_marks(self, req): accept = req.headers.get('Accept') if 'text/html' in accept: contentType = 'text/html; charset=utf-8' body = '<html><head></head><body>' body += f'<div>\u041e\u0446\u0435\u043d\u043a\u0438 ({len(self._marks)})</div>' body += '<ul>' for m in self._marks: body += f'<li>{m}: {self._marks[m]}</li>' body += '</ul>' body += '</body></html>' elif 'application/json' in accept: contentType = 'application/json; charset=utf-8' body = json.dumps(self._marks) else: return Response(406, 'Not Acceptable') body = body.encode('utf-8') headers = [('Content-Type', contentType), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) class HTTPError(Exception): def __init__(self, status, reason, body=None): super() self.status = status self.reason = reason self.body = body if __name__ == '__main__': print('[LOADING...]') host = socket.gethostbyname(socket.gethostname()) port = 7777 serv = MyHTTPServer(host, port, 'Marks') try: serv.serve_forever() except KeyboardInterrupt: print('Exit!') pass","title":"Lab1"},{"location":"lab1/#laboratory-work-1-working-with-sockets","text":"Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket, threading","title":"Laboratory Work 1: Working with sockets"},{"location":"lab1/#task-1","text":"Implement the client and server part of the application. The client sends a \"Hello, server\" message to the server. The message must be reflected on the server side. The server responds with a \"Hello, client\" message to the client. The message must be displayed to the client. Implement using the UDP protocol.","title":"Task 1"},{"location":"lab1/#configpy","text":"contains the necessary constants # address properties import socket HOST = socket.gethostbyname(socket.gethostname()) PORT = 7171 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8'","title":"config.py"},{"location":"lab1/#serverpy","text":"creates a server socket and waits for messages from the client from config import * CONNECT_MSG = \"Hello, client!\" def main(): UDPServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPServer.bind(ADDR) print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: msg, addr = UDPServer.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") UDPServer.sendto(CONNECT_MSG.encode(FORMAT), addr) if __name__ == \"__main__\": main()","title":"server.py"},{"location":"lab1/#clientpy","text":"connects to the server and sends it a message from config import * CONNECT_MSG = \"Hello, server!\" def main(): UDPClient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPClient.sendto(CONNECT_MSG.encode(FORMAT), ADDR) msg, addr = UDPClient.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") if __name__ == \"__main__\": main()","title":"client.py"},{"location":"lab1/#task-2","text":"Implement the client and server part of the application. The client asks the server to perform a mathematical operation: solving a quadratic equation, the parameters of which are entered from the keyboard. The server processes the received data and returns the result to the client. Implement using the TCP protocol","title":"Task 2"},{"location":"lab1/#configpy_1","text":"contains the necessary constants import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7272 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' MISTAKE = \"[INVALID INPUT] three coefficients needed, separated by space. Example: 1 2 3\"","title":"config.py"},{"location":"lab1/#serverpy_1","text":"creates a server socket, checks the input and sends an answer if possible from config import * from math import sqrt def calculate(a: float, b: float, c: float) -> str: d = b * b - 4 * a * c if d < 0: return 'No real roots' else: return ', '.join(str(r) for r in {(-b - sqrt(d)) / 2 / a, (-b + sqrt(d)) / 2 / a}) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen(1) print(f\"[STARTED] Server is listening on {HOST}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) print(f\"[NEW REQUEST from {addr[0]}:{addr[1]}]: {data.decode(FORMAT)}\") if not data: break try: values = [float(i) for i in data.decode(FORMAT).split(' ')] if len(values) != 3: raise ValueError conn.sendall(calculate(*values).encode(FORMAT)) except ValueError: conn.sendall(MISTAKE.encode(FORMAT)) print(\"the result was sent!\") conn.close() if __name__ == \"__main__\": main()","title":"server.py"},{"location":"lab1/#clientpy_1","text":"connects to the server and sends it values from config import * def main(): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(ADDR) print(f\"You are connected to {HOST}:{PORT}, \" f\"which calculates the roots of the quadratic equation:\" f\" a*x^2 + b*x + c = 0\") while True: try: inp = input(\"Enter the a, b, c: \") values = [float(i) for i in inp.split(' ')] if len(values) != 3: raise ValueError client.sendall(inp.encode(FORMAT)) print(f\"Answer: {client.recv(1024).decode(FORMAT)}\") break except ValueError: print(MISTAKE) if __name__ == \"__main__\": main()","title":"client.py"},{"location":"lab1/#task-3","text":"Implement the server part of the application. The client connects to the server. In response The client receives an http message containing a html page, which the server The client receives a http message containing a page which the server loads from the index.html file.","title":"Task 3"},{"location":"lab1/#indexhtml","text":"response template <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Lab 1 | Task 3</title> </head> <body> <iframe width=\"80%\" height=\"713\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ\" title=\"Rick Astley - Never Gonna Give You Up (Official Music Video)\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media;\" allowfullscreen style=\"margin-left: 10%; margin-right: 10%\"></iframe> </body> </html>","title":"index.html"},{"location":"lab1/#serverpy_2","text":"responding with HTML send_answer() sending HTTP answer, which contains index.html template, to the client main() - creating server socket and running it import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7373 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' def send_answer(conn, status=\"200 OK\", typ=\"text/html; charset=utf-8\", data=\"\"): conn.broadcast(b\"HTTP/1.1 \" + status.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"Server: simplehttp\\r\\n\") conn.broadcast(b\"Connection: close\\r\\n\") conn.broadcast(b\"Content-Type: \" + typ.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"\\r\\n\") conn.broadcast(data.encode(FORMAT)) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen() print(f\"[STARTED] Server is listening on {HOST}:{PORT}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) if not data: break print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") send_answer(conn, data=open('index.html', 'r').read()) conn.close() if __name__ == \"__main__\": main()","title":"server.py"},{"location":"lab1/#task-4","text":"Implement multiplayer chat.","title":"Task 4"},{"location":"lab1/#configpy_2","text":"contains the necessary constants import socket from threading import Thread # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7474 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' ASKING = \"Enter your username: \"","title":"config.py"},{"location":"lab1/#serverpy_3","text":"contains class Chat - s: socket.socket - server socket - users: Dict[socket.socket, str] - dictionary where key is client socket, value - username broadcast() - sending a message to all clients in users handle() - handling clients messages run() - starting server from typing import Dict from config import * class Chat: def __init__(self, host, port): self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.bind((HOST, PORT)) self.users: Dict[socket.socket, str] = dict() def broadcast(self, msg: str, username: str): for un in self.users: if self.users[un] == username: continue un.send(f\"{username}: {msg}\".encode(FORMAT)) def handle(self, user: socket.socket): while True: try: msg = user.recv(BUFFER_SIZE).decode(FORMAT) self.broadcast(msg, self.users[user]) except OSError: user.close() msg = f\"{self.users[user]} has left the chat :'(\" self.users.pop(user) self.broadcast(msg, '[sys]') break def run(self): self.s.listen() print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: conn, addr = self.s.accept() print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") conn.send(ASKING.encode(FORMAT)) username = conn.recv(1024).decode(FORMAT) self.users[conn] = username self.broadcast(f\"{username} has connected to the chat\", \"[sys]\") thread = Thread(target=self.handle, args=[conn]) thread.start() def main(): print('Server is starting...') chat = Chat(HOST, PORT) chat.run() if __name__ == \"__main__\": main()","title":"server.py"},{"location":"lab1/#clientpy_2","text":"Contains class User - username: str - client username - s: socket.socket - client socket receive() - getting messages from the server send() - sending new message to the server start() - starting client socket thread from config import * class User: def __init__(self, address): self.username = \"\" self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect(address) def receive(self): while True: try: msg = self.s.recv(BUFFER_SIZE).decode(FORMAT) if msg == ASKING: self.s.send(self.username.encode(FORMAT)) else: print(msg) except: print('Something went wrong. Disconnecting!') self.s.close() break def send(self): while True: msg = input() self.s.send(msg.encode(FORMAT)) def start(self): self.username = input(ASKING) recv_thread = Thread(target=self.receive) recv_thread.start() send_thread = Thread(target=self.send) send_thread.start() def main(): user = User(ADDR) user.start() if __name__ == \"__main__\": main()","title":"client.py"},{"location":"lab1/#task-5","text":"Write a simple web-server to handle GET and POST http requests by means of Python and socket library.","title":"Task 5"},{"location":"lab1/#requestpy","text":"contains Request class and Response class from functools import lru_cache from urllib.parse import parse_qs, urlparse class Request: def __init__(self, method, target, version, headers, rfile): self.method = method self.target = target self.version = version self.headers = headers self.rfile = rfile @property def path(self): return self.url.path @property @lru_cache(maxsize=None) def query(self): return parse_qs(self.url.query) @property @lru_cache(maxsize=None) def url(self): return urlparse(self.target) def body(self): size = self.headers.get('Content-Length') if not size: return None return self.rfile.read(size) class Response: def __init__(self, status, reason, headers=None, body=None): self.status = status self.reason = reason self.headers = headers self.body = body","title":"request.py"},{"location":"lab1/#serverpy_4","text":"HTTPServer. Source: https://iximiuz.com/ru/posts/writing-python-web-server-part-3/ import json import socket from request import Request, Response from email.parser import Parser MAX_LINE = 64 * 1024 MAX_HEADERS = 100 class MyHTTPServer: def __init__(self, host, port, name): self._host = host self._port = port self._name = name self._marks = {'\u0424\u0438\u0437\u043a\u0443\u043b\u044c\u0442\u0443\u0440\u0430': 5} print(f\"[RUNNING] Created HTTPServer '{name}'\") def serve_forever(self): serv_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0) try: serv_sock.bind((self._host, self._port)) serv_sock.listen() print(f\"[LISTENING] Server '{self._name}' on {self._host}:{self._port}\\r\\n\") while True: conn, addr = serv_sock.accept() print(f\"[NEW]: {addr}\") try: self.serve_client(conn) except Exception as e: print('[ERROR]: Client serving failed', e) finally: print('[EXIT]') serv_sock.close() def serve_client(self, conn): try: req = self.parse_request(conn) resp = self.handle_request(req) self.send_response(conn, resp) except ConnectionResetError: conn = None except Exception as e: self.send_error(conn, e) if conn: req.rfile.close() conn.close() def parse_request(self, conn): rfile = conn.makefile('rb') method, target, ver = self.parse_request_line(rfile) headers = self.parse_headers(rfile) host = headers.get('Host') if not host: raise HTTPError(400, 'Bad request', 'Host header is missing') if host != f'{self._host}:{self._port}': raise HTTPError(404, 'Not found') return Request(method, target, ver, headers, rfile) @staticmethod def parse_request_line(rfile): raw = rfile.readline(MAX_LINE + 1) if len(raw) > MAX_LINE: raise HTTPError(400, 'Bad request', 'Request line is too long') req_line = str(raw, 'iso-8859-1') words = req_line.split() if len(words) != 3: raise HTTPError(400, 'Bad request', 'Malformed request line') method, target, ver = words if ver != 'HTTP/1.1': raise HTTPError(505, 'HTTP Version Not Supported') return method, target, ver @staticmethod def parse_headers(rfile): headers = [] while True: line = rfile.readline(MAX_LINE + 1) if len(line) > MAX_LINE: raise HTTPError(494, 'Request header too large') if line in (b'\\r\\n', b'\\n', b''): break headers.append(line) if len(headers) > MAX_HEADERS: raise HTTPError(494, 'Too many headers') sheaders = b''.join(headers).decode('iso-8859-1') return Parser().parsestr(sheaders) def handle_request(self, req): if req.path == '/update' and req.method == 'POST': return self.handle_post_mark(req) if req.path == '/marks' and req.method == 'GET': return self.handle_get_marks(req) raise HTTPError(404, 'Not found') def send_response(self, conn, resp): wfile = conn.makefile('wb') status_line = f'HTTP/1.1 {resp.status} {resp.reason}\\r\\n' wfile.write(status_line.encode('iso-8859-1')) if resp.headers: for (key, value) in resp.headers: header_line = f'{key}: {value}\\r\\n' wfile.write(header_line.encode('iso-8859-1')) wfile.write(b'\\r\\n') if resp.body: wfile.write(resp.body) wfile.flush() wfile.close() def send_error(self, conn, err): try: status = err.status reason = err.reason body = (err.body or err.reason).encode('utf-8') except: status = 500 reason = b'Internal Server Error' body = b'Internal Server Error' resp = Response(status, reason, [('Content-Length', len(body))], body) self.send_response(conn, resp) def handle_post_mark(self, req): self._marks[req.query['name'][0]] = req.query['mark'][0] return Response(204, 'Created') def handle_get_marks(self, req): accept = req.headers.get('Accept') if 'text/html' in accept: contentType = 'text/html; charset=utf-8' body = '<html><head></head><body>' body += f'<div>\u041e\u0446\u0435\u043d\u043a\u0438 ({len(self._marks)})</div>' body += '<ul>' for m in self._marks: body += f'<li>{m}: {self._marks[m]}</li>' body += '</ul>' body += '</body></html>' elif 'application/json' in accept: contentType = 'application/json; charset=utf-8' body = json.dumps(self._marks) else: return Response(406, 'Not Acceptable') body = body.encode('utf-8') headers = [('Content-Type', contentType), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) class HTTPError(Exception): def __init__(self, status, reason, body=None): super() self.status = status self.reason = reason self.body = body if __name__ == '__main__': print('[LOADING...]') host = socket.gethostbyname(socket.gethostname()) port = 7777 serv = MyHTTPServer(host, port, 'Marks') try: serv.serve_forever() except KeyboardInterrupt: print('Exit!') pass","title":"server.py"},{"location":"lab2/","text":"Laboratory Work 2: Django Purpose of work : acquiring practical skills and abilities to implement Django 2.2 web services. Stack : Django Task Implement a website using Django 3 framework and PostgreSQL* DBMS, according to the variant of the laboratory work. Task description (variant 4) Tour list of the tour operator Stores information about tour name, tour description, tour period, payment conditions. The following functionality must be implemented: - Registration of new users. - Viewing and booking tours. User must be able to edit and delete their bookings. - Writing reviews for tours. When adding a comment the dates of the tour, comment text, rating (1-10), information about the commenter must be saved. - The administrator must be able to confirm tour bookings using Django-admin. - A table showing all sold tours by country should be generated in the client part. Diagram Models class Country(models.Model): name = models.CharField('Country name', max_length=64, unique=True) slug = models.SlugField('Country link', max_length=64, unique=True) description = models.CharField('Country description', max_length=1000, null=True) image = models.ImageField('Image of country', upload_to='images/', null=True, blank=True) def get_absolute_url(self): return reverse('country_details_url', kwargs={'slug': self.slug}) def __str__(self): return self.name class Tour(models.Model): title = models.CharField(max_length=150, db_index=True) description = models.CharField(max_length=1024, db_index=True) country = models.ForeignKey(Country, on_delete=models.CASCADE) slug = models.SlugField(max_length=150, unique=True) price_per_person = models.FloatField() nights_count = models.IntegerField() def __str__(self): return self.title def get_absolute_url(self): return reverse('tour_details_url', kwargs={'slug': self.slug}) class TourImage(models.Model): name = models.CharField('Tour image name', max_length=64, unique=True) image = models.ImageField(upload_to='images/', null=True, blank=True) tour = models.ForeignKey(Tour, on_delete=models.CASCADE, null=True, blank=True) def __str__(self): return self.name Customer = get_user_model() class TourConducting(models.Model): tour = models.ForeignKey(Tour, on_delete=models.CASCADE) customer = models.ForeignKey(Customer, on_delete=models.CASCADE) date_start = models.DateField() is_verified = models.BooleanField(default=False) is_paid = models.BooleanField(default=False) tourists = models.IntegerField(default=1) contact_info = models.TextField() review_text = models.TextField(null=True, default=None, blank=True) rate = models.IntegerField(null=True, default=None, blank=True) def __str__(self): status = 'PAID' if self.is_paid else 'VERIFIED' if self.is_verified else 'NEW' return f\"[{status}] {self.tour} / {self.customer}\" Urls urlpatterns = [ path('countries/', countries_list, name='countries_list_url'), path('countries/<str:slug>/', country_details, name='country_details_url'), path('tours/', tours_list, name='tours_list_url'), path('tours/<str:slug>/', tour_details, name='tour_details_url'), path('registration/', registration, name='registration_url'), path('login/', login_page, name='login_url'), path('logout/', logout_user, name='logout_url'), path('profile/', profile, name='profile_url'), path('sells/', sells, name='sells_url'), path('profile/<int:pk>/review/update/', ReviewUpdate.as_view()), path('profile/<int:pk>/delete/', TourConductingDelete.as_view()), path('profile/<int:pk>/update/', TourConductingUpdate.as_view()), ] Views Countries info def countries_list(request): countries = Country.objects.all() return render(request, 'WhoopsieTravel/countries.html', context={'countries': countries}) @login_required(login_url='login_url') def country_details(request, slug): country = Country.objects.get(slug__iexact=slug) tours = Tour.objects.filter(country__name=country.name) for t in tours: images = TourImage.objects.filter(tour__title=t.title) t.images = images return render(request, 'WhoopsieTravel/country_details.html', context={'country': country, 'tours': tours}) Tours info def tours_list(request): tours = Tour.objects.all() for t in tours: images = TourImage.objects.filter(tour__title=t.title) t.images = images return render(request, 'WhoopsieTravel/tours.html', context={'tours': tours}) @login_required(login_url='login_url') def tour_details(request, slug): tour = Tour.objects.get(slug__iexact=slug) rates = TourConducting.objects.filter(tour__title=tour.title).exclude(rate=None) images = TourImage.objects.filter(tour__title=tour.title) tour.images = images form = BookingForm(request.POST or None) if request.method == 'POST': form = BookingForm(request.POST) if form.is_valid(): form.save() return redirect('profile_url') isOrdered = TourConducting.objects.filter(customer__username=request.user.username, tour__title=tour.title, date_start__gt=datetime.date.today()) return render(request, 'WhoopsieTravel/tour_details.html', context={'tour': tour, 'form': form, 'ordered': isOrdered, 'rates': rates}) Registration and authentication def registration(request): if request.user.is_authenticated: return redirect('tours_list_url') else: form = CreateCustomerForm() if request.method == 'POST': form = CreateCustomerForm(request.POST) if form.is_valid(): form.save() messages.success(request, 'Account was created for ' + form.cleaned_data.get('username')) return redirect('login_url') return render(request, 'WhoopsieTravel/registration.html', context={'form': form}) def login_page(request): if request.user.is_authenticated: return redirect('tours_list_url') else: if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') user = authenticate(request, username=username, password=password) if user is not None: login(request, user) return redirect('profile_url') else: messages.info(request, 'Username OR password is incorrect') return render(request, 'WhoopsieTravel/login.html', context={}) def logout_user(request): logout(request) return redirect('login_url') Extra pages @login_required(login_url='login_url') def profile(request): tour_conducting = TourConducting.objects.filter(customer__username__iexact=request.user) tour_conducting = tour_conducting.order_by('date_start').reverse() return render(request, 'WhoopsieTravel/profile.html', context={'tc': tour_conducting, 'today': datetime.date.today()}) def sells(request): tour_conducting = TourConducting.objects.filter(is_paid=True).order_by('date_start').reverse() return render(request, 'WhoopsieTravel/sells.html', context={'tc': tour_conducting}) Django's views to CRUD operations class ReviewUpdate(UpdateView): model = TourConducting fields = ['review_text', 'rate'] success_url = '/travel/profile' template_name = 'WhoopsieTravel/review.html' class TourConductingDelete(DeleteView): model = TourConducting template_name = 'WhoopsieTravel/reserve_delete.html' success_url = '/travel/profile' class TourConductingUpdate(UpdateView): model = TourConducting fields = ['date_start', 'contact_info', 'tourists'] success_url = '/travel/profile' template_name = 'WhoopsieTravel/reserve_update.html' Results","title":"Lab2"},{"location":"lab2/#laboratory-work-2-django","text":"Purpose of work : acquiring practical skills and abilities to implement Django 2.2 web services. Stack : Django","title":"Laboratory Work 2: Django"},{"location":"lab2/#task","text":"Implement a website using Django 3 framework and PostgreSQL* DBMS, according to the variant of the laboratory work.","title":"Task"},{"location":"lab2/#task-description-variant-4","text":"Tour list of the tour operator Stores information about tour name, tour description, tour period, payment conditions. The following functionality must be implemented: - Registration of new users. - Viewing and booking tours. User must be able to edit and delete their bookings. - Writing reviews for tours. When adding a comment the dates of the tour, comment text, rating (1-10), information about the commenter must be saved. - The administrator must be able to confirm tour bookings using Django-admin. - A table showing all sold tours by country should be generated in the client part.","title":"Task description (variant 4)"},{"location":"lab2/#diagram","text":"","title":"Diagram"},{"location":"lab2/#models","text":"class Country(models.Model): name = models.CharField('Country name', max_length=64, unique=True) slug = models.SlugField('Country link', max_length=64, unique=True) description = models.CharField('Country description', max_length=1000, null=True) image = models.ImageField('Image of country', upload_to='images/', null=True, blank=True) def get_absolute_url(self): return reverse('country_details_url', kwargs={'slug': self.slug}) def __str__(self): return self.name class Tour(models.Model): title = models.CharField(max_length=150, db_index=True) description = models.CharField(max_length=1024, db_index=True) country = models.ForeignKey(Country, on_delete=models.CASCADE) slug = models.SlugField(max_length=150, unique=True) price_per_person = models.FloatField() nights_count = models.IntegerField() def __str__(self): return self.title def get_absolute_url(self): return reverse('tour_details_url', kwargs={'slug': self.slug}) class TourImage(models.Model): name = models.CharField('Tour image name', max_length=64, unique=True) image = models.ImageField(upload_to='images/', null=True, blank=True) tour = models.ForeignKey(Tour, on_delete=models.CASCADE, null=True, blank=True) def __str__(self): return self.name Customer = get_user_model() class TourConducting(models.Model): tour = models.ForeignKey(Tour, on_delete=models.CASCADE) customer = models.ForeignKey(Customer, on_delete=models.CASCADE) date_start = models.DateField() is_verified = models.BooleanField(default=False) is_paid = models.BooleanField(default=False) tourists = models.IntegerField(default=1) contact_info = models.TextField() review_text = models.TextField(null=True, default=None, blank=True) rate = models.IntegerField(null=True, default=None, blank=True) def __str__(self): status = 'PAID' if self.is_paid else 'VERIFIED' if self.is_verified else 'NEW' return f\"[{status}] {self.tour} / {self.customer}\"","title":"Models"},{"location":"lab2/#urls","text":"urlpatterns = [ path('countries/', countries_list, name='countries_list_url'), path('countries/<str:slug>/', country_details, name='country_details_url'), path('tours/', tours_list, name='tours_list_url'), path('tours/<str:slug>/', tour_details, name='tour_details_url'), path('registration/', registration, name='registration_url'), path('login/', login_page, name='login_url'), path('logout/', logout_user, name='logout_url'), path('profile/', profile, name='profile_url'), path('sells/', sells, name='sells_url'), path('profile/<int:pk>/review/update/', ReviewUpdate.as_view()), path('profile/<int:pk>/delete/', TourConductingDelete.as_view()), path('profile/<int:pk>/update/', TourConductingUpdate.as_view()), ]","title":"Urls"},{"location":"lab2/#views","text":"Countries info def countries_list(request): countries = Country.objects.all() return render(request, 'WhoopsieTravel/countries.html', context={'countries': countries}) @login_required(login_url='login_url') def country_details(request, slug): country = Country.objects.get(slug__iexact=slug) tours = Tour.objects.filter(country__name=country.name) for t in tours: images = TourImage.objects.filter(tour__title=t.title) t.images = images return render(request, 'WhoopsieTravel/country_details.html', context={'country': country, 'tours': tours}) Tours info def tours_list(request): tours = Tour.objects.all() for t in tours: images = TourImage.objects.filter(tour__title=t.title) t.images = images return render(request, 'WhoopsieTravel/tours.html', context={'tours': tours}) @login_required(login_url='login_url') def tour_details(request, slug): tour = Tour.objects.get(slug__iexact=slug) rates = TourConducting.objects.filter(tour__title=tour.title).exclude(rate=None) images = TourImage.objects.filter(tour__title=tour.title) tour.images = images form = BookingForm(request.POST or None) if request.method == 'POST': form = BookingForm(request.POST) if form.is_valid(): form.save() return redirect('profile_url') isOrdered = TourConducting.objects.filter(customer__username=request.user.username, tour__title=tour.title, date_start__gt=datetime.date.today()) return render(request, 'WhoopsieTravel/tour_details.html', context={'tour': tour, 'form': form, 'ordered': isOrdered, 'rates': rates}) Registration and authentication def registration(request): if request.user.is_authenticated: return redirect('tours_list_url') else: form = CreateCustomerForm() if request.method == 'POST': form = CreateCustomerForm(request.POST) if form.is_valid(): form.save() messages.success(request, 'Account was created for ' + form.cleaned_data.get('username')) return redirect('login_url') return render(request, 'WhoopsieTravel/registration.html', context={'form': form}) def login_page(request): if request.user.is_authenticated: return redirect('tours_list_url') else: if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') user = authenticate(request, username=username, password=password) if user is not None: login(request, user) return redirect('profile_url') else: messages.info(request, 'Username OR password is incorrect') return render(request, 'WhoopsieTravel/login.html', context={}) def logout_user(request): logout(request) return redirect('login_url') Extra pages @login_required(login_url='login_url') def profile(request): tour_conducting = TourConducting.objects.filter(customer__username__iexact=request.user) tour_conducting = tour_conducting.order_by('date_start').reverse() return render(request, 'WhoopsieTravel/profile.html', context={'tc': tour_conducting, 'today': datetime.date.today()}) def sells(request): tour_conducting = TourConducting.objects.filter(is_paid=True).order_by('date_start').reverse() return render(request, 'WhoopsieTravel/sells.html', context={'tc': tour_conducting}) Django's views to CRUD operations class ReviewUpdate(UpdateView): model = TourConducting fields = ['review_text', 'rate'] success_url = '/travel/profile' template_name = 'WhoopsieTravel/review.html' class TourConductingDelete(DeleteView): model = TourConducting template_name = 'WhoopsieTravel/reserve_delete.html' success_url = '/travel/profile' class TourConductingUpdate(UpdateView): model = TourConducting fields = ['date_start', 'contact_info', 'tourists'] success_url = '/travel/profile' template_name = 'WhoopsieTravel/reserve_update.html' Results","title":"Views"}]}