{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"labs/lab1/","text":"Laboratory Work 1: Working with sockets Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket, threading Task 1 Implement the client and server part of the application. The client sends a \"Hello, server\" message to the server. The message must be reflected on the server side. The server responds with a \"Hello, client\" message to the client. The message must be displayed to the client. Implement using the UDP protocol. Structure config.py - contains the necessary constants import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7171 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' server.py - \u0441reates a server socket and waits for messages from the client from config import * CONNECT_MSG = \"Hello, client!\" def main(): UDPServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPServer.bind(ADDR) print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: msg, addr = UDPServer.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") UDPServer.sendto(CONNECT_MSG.encode(FORMAT), addr) if __name__ == \"__main__\": main() client.py - connects to the server and sends it a message from config import * CONNECT_MSG = \"Hello, server!\" def main(): UDPClient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPClient.sendto(CONNECT_MSG.encode(FORMAT), ADDR) msg, addr = UDPClient.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") if __name__ == \"__main__\": main() Task 2 Implement the client and server part of the application. The client asks the server to perform a mathematical operation: solving a quadratic equation, the parameters of which are entered from the keyboard. The server processes the received data and returns the result to the client. Implement using the TCP protocol Structure config.py - contains the necessary constants import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7272 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' MISTAKE = \"[INVALID INPUT] three coefficients needed, separated by space. Example: 1 2 3\" server.py - creates a server socket, checks the input and sends an answer if possible from config import * from math import sqrt def calculate(a: float, b: float, c: float) -> str: d = b * b - 4 * a * c if d < 0: return 'No real roots' else: return ', '.join(str(r) for r in {(-b - sqrt(d)) / 2 / a, (-b + sqrt(d)) / 2 / a}) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen(1) print(f\"[STARTED] Server is listening on {HOST}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) print(f\"[NEW REQUEST from {addr[0]}:{addr[1]}]: {data.decode(FORMAT)}\") if not data: break try: values = [float(i) for i in data.decode(FORMAT).split(' ')] if len(values) != 3: raise ValueError conn.sendall(calculate(*values).encode(FORMAT)) except ValueError: conn.sendall(MISTAKE.encode(FORMAT)) print(\"the result was sent!\") conn.close() if __name__ == \"__main__\": main() client.py - connects to the server and sends it values from config import * def main(): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(ADDR) print(f\"You are connected to {HOST}:{PORT}, \" f\"which calculates the roots of the quadratic equation:\" f\" a*x^2 + b*x + c = 0\") while True: try: inp = input(\"Enter the a, b, c: \") values = [float(i) for i in inp.split(' ')] if len(values) != 3: raise ValueError client.sendall(inp.encode(FORMAT)) print(f\"Answer: {client.recv(1024).decode(FORMAT)}\") break except ValueError: print(MISTAKE) if __name__ == \"__main__\": main() Task 3 Implement the server part of the application. The client connects to the server. In response The client receives an http message containing an html page, which the server The client receives an http message containing a page which the server loads from the index.html file. Structure index.html - response template <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Lab 1 | Task 3</title> </head> <body> <iframe width=\"80%\" height=\"713\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ\" title=\"Rick Astley - Never Gonna Give You Up (Official Music Video)\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media;\" allowfullscreen style=\"margin-left: 10%; margin-right: 10%\"></iframe> </body> </html> server.py - responding with HTML send_answer() sending HTTP answer, which contains index.html template, to the client main() - creating server socket and running it import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7373 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' def send_answer(conn, status=\"200 OK\", typ=\"text/html; charset=utf-8\", data=\"\"): conn.broadcast(b\"HTTP/1.1 \" + status.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"Server: simplehttp\\r\\n\") conn.broadcast(b\"Connection: close\\r\\n\") conn.broadcast(b\"Content-Type: \" + typ.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"\\r\\n\") conn.broadcast(data.encode(FORMAT)) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen() print(f\"[STARTED] Server is listening on {HOST}:{PORT}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) if not data: break print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") send_answer(conn, data=open('index.html', 'r').read()) conn.close() if __name__ == \"__main__\": main() Task 4 Implement multiplayer chat. Structure config.py import socket from threading import Thread # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7474 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' ASKING = \"Enter your username: \" server.py from typing import Dict from config import * class Chat: def __init__(self, host, port): self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.bind((HOST, PORT)) self.users: Dict[socket.socket, str] = dict() def broadcast(self, msg: str, username: str): for un in self.users: if self.users[un] == username: continue un.send(f\"{username}: {msg}\".encode(FORMAT)) def handle(self, user: socket.socket): while True: try: msg = user.recv(BUFFER_SIZE).decode(FORMAT) self.broadcast(msg, self.users[user]) except OSError: user.close() msg = f\"{self.users[user]} has left the chat :'(\" self.users.pop(user) self.broadcast(msg, '[sys]') break def run(self): self.s.listen() print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: conn, addr = self.s.accept() print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") conn.send(ASKING.encode(FORMAT)) username = conn.recv(1024).decode(FORMAT) self.users[conn] = username self.broadcast(f\"{username} has connected to the chat\", \"[sys]\") thread = Thread(target=self.handle, args=[conn]) thread.start() def main(): print('Server is starting...') chat = Chat(HOST, PORT) chat.run() if __name__ == \"__main__\": main() client.py from config import * class User: def __init__(self, address): self.username = \"\" self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect(address) def receive(self): while True: try: msg = self.s.recv(BUFFER_SIZE).decode(FORMAT) if msg == ASKING: self.s.send(self.username.encode(FORMAT)) else: print(msg) except: print('Something went wrong. Disconnecting!') self.s.close() break def send(self): while True: msg = input() self.s.send(msg.encode(FORMAT)) def start(self): self.username = input(ASKING) recv_thread = Thread(target=self.receive) recv_thread.start() send_thread = Thread(target=self.send) send_thread.start() def main(): user = User(ADDR) user.start() if __name__ == \"__main__\": main() Task 5 Write a simple web-server to handle GET and POST http requests by means of Python and socket library. Structure \ud83d\udd7a\ud83d\udd7a\ud83d\udd7a","title":"Laboratory Work 1: Working with sockets"},{"location":"labs/lab1/#laboratory-work-1-working-with-sockets","text":"Purpose of work : to master the practical skills and abilities to implement web-servers and the use of sockets. Stack : Python libs socket, threading","title":"Laboratory Work 1: Working with sockets"},{"location":"labs/lab1/#task-1","text":"Implement the client and server part of the application. The client sends a \"Hello, server\" message to the server. The message must be reflected on the server side. The server responds with a \"Hello, client\" message to the client. The message must be displayed to the client. Implement using the UDP protocol.","title":"Task 1"},{"location":"labs/lab1/#structure","text":"","title":"Structure"},{"location":"labs/lab1/#configpy-contains-the-necessary-constants","text":"import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7171 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8'","title":"config.py - contains the necessary constants"},{"location":"labs/lab1/#serverpy-reates-a-server-socket-and-waits-for-messages-from-the-client","text":"from config import * CONNECT_MSG = \"Hello, client!\" def main(): UDPServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPServer.bind(ADDR) print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: msg, addr = UDPServer.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") UDPServer.sendto(CONNECT_MSG.encode(FORMAT), addr) if __name__ == \"__main__\": main()","title":"server.py - \u0441reates a server socket and waits for messages from the client"},{"location":"labs/lab1/#clientpy-connects-to-the-server-and-sends-it-a-message","text":"from config import * CONNECT_MSG = \"Hello, server!\" def main(): UDPClient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) UDPClient.sendto(CONNECT_MSG.encode(FORMAT), ADDR) msg, addr = UDPClient.recvfrom(BUFFER_SIZE) print(f\"[{addr[0]}:{addr[1]}]: {msg.decode(FORMAT)}\") if __name__ == \"__main__\": main()","title":"client.py - connects to the server and sends it a message"},{"location":"labs/lab1/#task-2","text":"Implement the client and server part of the application. The client asks the server to perform a mathematical operation: solving a quadratic equation, the parameters of which are entered from the keyboard. The server processes the received data and returns the result to the client. Implement using the TCP protocol","title":"Task 2"},{"location":"labs/lab1/#structure_1","text":"","title":"Structure"},{"location":"labs/lab1/#configpy-contains-the-necessary-constants_1","text":"import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7272 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' MISTAKE = \"[INVALID INPUT] three coefficients needed, separated by space. Example: 1 2 3\"","title":"config.py - contains the necessary constants"},{"location":"labs/lab1/#serverpy-creates-a-server-socket-checks-the-input-and-sends-an-answer-if-possible","text":"from config import * from math import sqrt def calculate(a: float, b: float, c: float) -> str: d = b * b - 4 * a * c if d < 0: return 'No real roots' else: return ', '.join(str(r) for r in {(-b - sqrt(d)) / 2 / a, (-b + sqrt(d)) / 2 / a}) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen(1) print(f\"[STARTED] Server is listening on {HOST}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) print(f\"[NEW REQUEST from {addr[0]}:{addr[1]}]: {data.decode(FORMAT)}\") if not data: break try: values = [float(i) for i in data.decode(FORMAT).split(' ')] if len(values) != 3: raise ValueError conn.sendall(calculate(*values).encode(FORMAT)) except ValueError: conn.sendall(MISTAKE.encode(FORMAT)) print(\"the result was sent!\") conn.close() if __name__ == \"__main__\": main()","title":"server.py - creates a server socket, checks the input and sends an answer if possible"},{"location":"labs/lab1/#clientpy-connects-to-the-server-and-sends-it-values","text":"from config import * def main(): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(ADDR) print(f\"You are connected to {HOST}:{PORT}, \" f\"which calculates the roots of the quadratic equation:\" f\" a*x^2 + b*x + c = 0\") while True: try: inp = input(\"Enter the a, b, c: \") values = [float(i) for i in inp.split(' ')] if len(values) != 3: raise ValueError client.sendall(inp.encode(FORMAT)) print(f\"Answer: {client.recv(1024).decode(FORMAT)}\") break except ValueError: print(MISTAKE) if __name__ == \"__main__\": main()","title":"client.py - connects to the server and sends it values"},{"location":"labs/lab1/#task-3","text":"Implement the server part of the application. The client connects to the server. In response The client receives an http message containing an html page, which the server The client receives an http message containing a page which the server loads from the index.html file.","title":"Task 3"},{"location":"labs/lab1/#structure_2","text":"","title":"Structure"},{"location":"labs/lab1/#indexhtml-response-template","text":"<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Lab 1 | Task 3</title> </head> <body> <iframe width=\"80%\" height=\"713\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ\" title=\"Rick Astley - Never Gonna Give You Up (Official Music Video)\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media;\" allowfullscreen style=\"margin-left: 10%; margin-right: 10%\"></iframe> </body> </html>","title":"index.html - response template"},{"location":"labs/lab1/#serverpy-responding-with-html","text":"send_answer() sending HTTP answer, which contains index.html template, to the client main() - creating server socket and running it import socket # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7373 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 1024 FORMAT = 'utf-8' def send_answer(conn, status=\"200 OK\", typ=\"text/html; charset=utf-8\", data=\"\"): conn.broadcast(b\"HTTP/1.1 \" + status.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"Server: simplehttp\\r\\n\") conn.broadcast(b\"Connection: close\\r\\n\") conn.broadcast(b\"Content-Type: \" + typ.encode(FORMAT) + b\"\\r\\n\") conn.broadcast(b\"\\r\\n\") conn.broadcast(data.encode(FORMAT)) def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(ADDR) server.listen() print(f\"[STARTED] Server is listening on {HOST}:{PORT}\") while True: conn, addr = server.accept() data = conn.recv(BUFFER_SIZE) if not data: break print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") send_answer(conn, data=open('index.html', 'r').read()) conn.close() if __name__ == \"__main__\": main()","title":"server.py - responding with HTML"},{"location":"labs/lab1/#task-4","text":"Implement multiplayer chat.","title":"Task 4"},{"location":"labs/lab1/#structure_3","text":"","title":"Structure"},{"location":"labs/lab1/#configpy","text":"import socket from threading import Thread # address properties HOST = socket.gethostbyname(socket.gethostname()) PORT = 7474 ADDR = (HOST, PORT) # message properties BUFFER_SIZE = 64 FORMAT = 'utf-8' ASKING = \"Enter your username: \"","title":"config.py"},{"location":"labs/lab1/#serverpy","text":"from typing import Dict from config import * class Chat: def __init__(self, host, port): self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.bind((HOST, PORT)) self.users: Dict[socket.socket, str] = dict() def broadcast(self, msg: str, username: str): for un in self.users: if self.users[un] == username: continue un.send(f\"{username}: {msg}\".encode(FORMAT)) def handle(self, user: socket.socket): while True: try: msg = user.recv(BUFFER_SIZE).decode(FORMAT) self.broadcast(msg, self.users[user]) except OSError: user.close() msg = f\"{self.users[user]} has left the chat :'(\" self.users.pop(user) self.broadcast(msg, '[sys]') break def run(self): self.s.listen() print(f\"[STARTED] server is working on {HOST}:{PORT}\") while True: conn, addr = self.s.accept() print(f\"[NEW CONNECTION]: {addr[0]}:{addr[1]}\") conn.send(ASKING.encode(FORMAT)) username = conn.recv(1024).decode(FORMAT) self.users[conn] = username self.broadcast(f\"{username} has connected to the chat\", \"[sys]\") thread = Thread(target=self.handle, args=[conn]) thread.start() def main(): print('Server is starting...') chat = Chat(HOST, PORT) chat.run() if __name__ == \"__main__\": main()","title":"server.py"},{"location":"labs/lab1/#clientpy","text":"from config import * class User: def __init__(self, address): self.username = \"\" self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect(address) def receive(self): while True: try: msg = self.s.recv(BUFFER_SIZE).decode(FORMAT) if msg == ASKING: self.s.send(self.username.encode(FORMAT)) else: print(msg) except: print('Something went wrong. Disconnecting!') self.s.close() break def send(self): while True: msg = input() self.s.send(msg.encode(FORMAT)) def start(self): self.username = input(ASKING) recv_thread = Thread(target=self.receive) recv_thread.start() send_thread = Thread(target=self.send) send_thread.start() def main(): user = User(ADDR) user.start() if __name__ == \"__main__\": main()","title":"client.py"},{"location":"labs/lab1/#task-5","text":"Write a simple web-server to handle GET and POST http requests by means of Python and socket library.","title":"Task 5"},{"location":"labs/lab1/#structure_4","text":"\ud83d\udd7a\ud83d\udd7a\ud83d\udd7a","title":"Structure"}]}